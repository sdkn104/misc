# Edge Extension Internal Distribution Setup Script
# This script implements all steps for Edge extension deployment

param(
    [string]$ExtensionName = "SampleExtension",
    [string]$Version = "1.0.0",
    [string]$ServerPort = 8443,
    [string]$LocalhostFQDN = "localhost"
)

# Define base directories
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$baseDir = Split-Path -Parent $scriptDir
$extensionDir = Join-Path $baseDir "extension"
$outputDir = Join-Path $baseDir "output"
$certDir = Join-Path $baseDir "certificates"
$serverDir = Join-Path $baseDir "server"

# Create necessary directories
Write-Host "Creating directory structure..." -ForegroundColor Cyan
New-Item -ItemType Directory -Path $extensionDir -Force | Out-Null
New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
New-Item -ItemType Directory -Path $certDir -Force | Out-Null
New-Item -ItemType Directory -Path $serverDir -Force | Out-Null

# Step 1: Create sample extension
Write-Host "`n=== Step 1: Creating sample extension ===" -ForegroundColor Green
$manifestPath = Join-Path $extensionDir "manifest.json"
$manifestContent = @{
    "manifest_version" = 3
    "name" = $ExtensionName
    "version" = $Version
    "description" = "Sample extension for internal distribution"
    "permissions" = @("tabs", "activeTab")
    "action" = @{
        "default_popup" = "popup.html"
        "default_title" = $ExtensionName
    }
}

$manifestContent | ConvertTo-Json | Set-Content -Path $manifestPath -Encoding UTF8
Write-Host "Created manifest.json"

# Create popup.html
$popupPath = Join-Path $extensionDir "popup.html"
$popupContent = @"
<!DOCTYPE html>
<html>
<head>
    <style>
        body { width: 300px; padding: 10px; font-family: Arial; }
        h1 { font-size: 14px; }
    </style>
</head>
<body>
    <h1>$ExtensionName</h1>
    <p>Extension is active</p>
</body>
</html>
"@
Set-Content -Path $popupPath -Value $popupContent -Encoding UTF8
Write-Host "Created popup.html"

# Create popup.js
$scriptPath = Join-Path $extensionDir "popup.js"
$scriptContent = @"
// Sample extension script
console.log('Extension loaded successfully');
"@
Set-Content -Path $scriptPath -Value $scriptContent -Encoding UTF8
Write-Host "Created popup.js"

Write-Host "Extension structure created" -ForegroundColor Green

# Step 2: Generate signing key (PEM format for demo purposes)
Write-Host "`n=== Step 2: Preparing extension signing ===" -ForegroundColor Green
$keyPath = Join-Path $outputDir "extension_key.pem"

if (-not (Test-Path $keyPath)) {
    Write-Host "Note: For production, you need to sign the extension with Microsoft's signing tool"
    Write-Host "This script creates the extension folder structure for manual signing"
    Write-Host "Key path prepared: $keyPath"
} else {
    Write-Host "Signing key already exists"
}

# For Windows, we'll create a ZIP that can be signed using Microsoft Edge's extension signing
$zipPath = Join-Path $outputDir "$ExtensionName.zip"
Write-Host "Creating extension package..."

# Create a ZIP file of the extension
Add-Type -AssemblyName System.IO.Compression.FileSystem
if (Test-Path $zipPath) { Remove-Item $zipPath }
[System.IO.Compression.ZipFile]::CreateFromDirectory($extensionDir, $zipPath)
Write-Host "Created extension package: $zipPath"

# Step 3: Extension ID (placeholder - would be generated by signing)
Write-Host "`n=== Step 3: Extension ID ===" -ForegroundColor Green
$extensionId = "Sample-Extension-ID-Placeholder"
Write-Host "Extension ID (will be generated during signing): $extensionId"

# Create a file to store the extension ID
$idPath = Join-Path $outputDir "EXTENSION_ID.txt"
@"
Extension Name: $ExtensionName
Extension ID: $extensionId
Version: $Version
Note: The actual extension ID will be generated when you sign the extension.
"@ | Set-Content -Path $idPath
Write-Host "Extension ID information saved to: $idPath"

# Step 4: Create update.xml
Write-Host "`n=== Step 4: Creating update.xml ===" -ForegroundColor Green
$updateXmlPath = Join-Path $outputDir "update.xml"
$updateXmlContent = @"
<?xml version='1.0' encoding='UTF-8'?>
<gupdate xmlns='http://www.google.com/update2/response' protocol='3.0'>
  <app appid='$extensionId'>
    <updatecheck codebase='https://${LocalhostFQDN}:$ServerPort/$ExtensionName.crx' version='$Version' />
  </app>
</gupdate>
"@
Set-Content -Path $updateXmlPath -Value $updateXmlContent -Encoding UTF8
Write-Host "Created update.xml at: $updateXmlPath"

# Step 5: Create localhost SSL certificate
Write-Host "`n=== Step 5: Creating self-signed certificate ===" -ForegroundColor Green
$certPath = Join-Path $certDir "localhost.cer"
$keyFile = Join-Path $certDir "localhost.key"
$pfxPath = Join-Path $certDir "localhost.pfx"

# Check if certificate already exists
if (-not (Test-Path $certPath)) {
    # Create self-signed certificate
    $cert = New-SelfSignedCertificate -CertStoreLocation "cert:\CurrentUser\My" `
        -DnsName "localhost", "127.0.0.1" `
        -FriendlyName "LocalhostEdgeExtension" `
        -NotAfter (Get-Date).AddYears(1)
    
    Write-Host "Created self-signed certificate: $($cert.Thumbprint)"
    
    # Export certificate
    Export-Certificate -Cert $cert -FilePath $certPath -Force | Out-Null
    Write-Host "Exported certificate to: $certPath"
    
    # Export as PFX for Python server
    $password = ConvertTo-SecureString -String "Extension@123" -AsPlainText -Force
    Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $password -Force | Out-Null
    Write-Host "Exported PFX certificate to: $pfxPath"
} else {
    Write-Host "Certificate already exists at: $certPath"
}

# Step 6: Create Python HTTPS server script
Write-Host "`n=== Step 6: Creating Python HTTPS server ===" -ForegroundColor Green
$pythonServerPath = Join-Path $serverDir "https_server.py"
$pythonServerContent = @"
#!/usr/bin/env python3
import ssl
import http.server
import socketserver
import os
import sys
from pathlib import Path

# Configuration
PORT = $ServerPort
CERT_FILE = r'$pfxPath'
CERT_PASSWORD = 'Extension@123'
SERVE_DIR = r'$outputDir'

os.chdir(SERVE_DIR)

class MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET')
        super().end_headers()
    
    def log_message(self, format, *args):
        print(f'[{self.log_date_time_string()}] {format % args}')

def run_server():
    print(f'Starting HTTPS server on port {PORT}...')
    print(f'Serving files from: {SERVE_DIR}')
    print(f'Press Ctrl+C to stop')
    
    try:
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(CERT_FILE, password=lambda: CERT_PASSWORD.encode())
        
        with socketserver.TCPServer(('', PORT), MyHTTPRequestHandler) as httpd:
            httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
            httpd.serve_forever()
    except Exception as e:
        print(f'Error: {e}', file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    run_server()
"@
Set-Content -Path $pythonServerPath -Value $pythonServerContent -Encoding UTF8
Write-Host "Created Python HTTPS server script at: $pythonServerPath"

# Step 7: Create registry configuration script
Write-Host "`n=== Step 7: Creating registry configuration ===" -ForegroundColor Green
$registryScriptPath = Join-Path $scriptDir "configure_registry.ps1"
$registryScriptContent = @"
# Registry configuration for Edge extension internal distribution
# This script must be run as Administrator

`$extensionId = '$extensionId'
`$updateUrl = 'https://${LocalhostFQDN}:$ServerPort/update.xml'

# Registry path for Edge extensions
`$regPath = 'HKLM:\SOFTWARE\Microsoft\Edge\Extensions'

Write-Host 'Configuring Windows Registry for Edge extension...' -ForegroundColor Cyan

# Create extension registry entry
if (-not (Test-Path `$regPath)) {
    New-Item -Path `$regPath -Force | Out-Null
    Write-Host "Created registry path: `$regPath"
}

`$extPath = Join-Path `$regPath `$extensionId
if (-not (Test-Path `$extPath)) {
    New-Item -Path `$extPath -Force | Out-Null
}

# Set registry values
New-ItemProperty -Path `$extPath -Name 'update_url' -Value `$updateUrl -PropertyType String -Force | Out-Null
Write-Host "Set update URL: `$updateUrl"

Write-Host 'Registry configuration completed successfully' -ForegroundColor Green
Write-Host "Extension ID: `$extensionId"
Write-Host "Update URL: `$updateUrl"
"@
Set-Content -Path $registryScriptPath -Value $registryScriptContent -Encoding UTF8
Write-Host "Created registry configuration script at: $registryScriptPath"

# Create startup batch file for easy server launch
Write-Host "`n=== Creating server startup scripts ===" -ForegroundColor Green
$batchPath = Join-Path $serverDir "start_server.bat"
$batchContent = @"
@echo off
echo Starting Edge Extension HTTPS Server...
cd /d "$serverDir"
python https_server.py
"@
Set-Content -Path $batchPath -Value $batchContent -Encoding ASCII
Write-Host "Created batch startup script at: $batchPath"

# Create PowerShell startup script
$psStartPath = Join-Path $serverDir "start_server.ps1"
$psStartContent = @"
# Start Edge Extension HTTPS Server
Write-Host 'Starting Edge Extension HTTPS Server...' -ForegroundColor Cyan
Write-Host "Server Port: $ServerPort"
Write-Host "Serving from: $outputDir"

python "$pythonServerPath"
"@
Set-Content -Path $psStartPath -Value $psStartContent -Encoding UTF8
Write-Host "Created PowerShell startup script at: $psStartPath"

# Summary
Write-Host "`n" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Edge Extension Deployment Setup Complete" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan

Write-Host "`nGenerated Files and Directories:" -ForegroundColor Yellow
Write-Host "  Extension source:     $extensionDir"
Write-Host "  Output directory:     $outputDir"
Write-Host "  Certificates:         $certDir"
Write-Host "  Server scripts:       $serverDir"

Write-Host "`nNext Steps:" -ForegroundColor Yellow
Write-Host "1. Sign the extension package ($zipPath) using Microsoft Edge signing tool"
Write-Host "2. Rename the signed file to: $ExtensionName.crx and place in $outputDir"
Write-Host "3. Run registry configuration (as Administrator):"
Write-Host "   powershell -ExecutionPolicy Bypass -File `"$registryScriptPath`""
Write-Host "4. Start the HTTPS server:"
Write-Host "   python `"$pythonServerPath`""
Write-Host "5. Users can install the extension via Edge Group Policy or manual installation"

Write-Host "`nImportant Notes:" -ForegroundColor Yellow
Write-Host "- Certificate password: Extension@123"
Write-Host "- Self-signed certificate will need to be trusted on client machines"
Write-Host "- Registry configuration requires Administrator privileges"
Write-Host "- Server should be run on a machine accessible to client machines"
