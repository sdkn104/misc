set TESSDATA_PREFIX=C:\Users\QP48568\Desktop\tesseract\lang\tesseract-ocr
set SCROLLVIEW_PATH=C:\Users\QP48568\Desktop\tesseract\piccolo-1.2\build

"C:\Program Files\Microsoft Visual Studio 9.0\Common7\IDE\VCExpress.exe"

cd C:\Users\QP48568\Desktop\tesseract\tessrun\run

..\..\Build\tesseract-ocr\vs2008\Debug\tabrecod.exe all.tif out -l eng -psm 2 myconf.txt

..\..\Build\tesseract-ocr\vs2008\Debug\tabrecod.exe my_cell_list.txt out -l jpn -psm 7 myconf2.txt


C:\Users\QP48568\Desktop\Build\tesseract-3.02\vs2008\LIB_Release\tesseract.exe table.tif out -l jpn


------------------------------------------------------------------------------
pagesegmode values are:
0 = Orientation and script detection (OSD) only.  -- no OCR
1 = Automatic page segmentation with OSD.  -- do OCR
2 = Automatic page segmentation, but no OSD, or OCR -- no OCR
3 = Fully automatic page segmentation, but no OSD. (Default)
4 = Assume a single column of text of variable sizes.
5 = Assume a single uniform block of vertically aligned text.
6 = Assume a single uniform block of text.
7 = Treat the image as a single text line.
8 = Treat the image as a single word.
9 = Treat the image as a single word in a circle.
10 = Treat the image as a single character.

------------------------------------------------------------------------------
int main
 TessBaseAPI::ProcessPages
  TessBaseAPI::ProcessPage
   TessBaseAPI::AnalyseLayout  or  TessBaseAPI::Recognize


TessBaseAPI::AnalyseLayout, TessBaseAPI::Recognize
 TessBaseAPI::FindLines
  Tesseract::SegmentPage
   Tesseract::AutoPageSeg
    Tesseract::SetupPageSegAndDetectOrientation
     LineFinder::FindAndRemoveLines 
         <-remove_nontext_regions<-orientation_and_script_detection
                   <-TessBaseAPI::DetectOS<-TessBaseAPIDetectOS<-0
      LineFinder::GetLineMasks
      LineFinder::FindAndRemoveHLines
     find_components
     ColumnFinder
    ColumnFinder::FindBlocks
     TableFinder::LocateTables(
          TableRecognizer::RecognizeTable
            TableRecognizer::RecognizeLinedTable
   Textord::TextordPage() -- create row/werd structures
 Tesseract::recog_all_words(page_res_,) -- only when called from TessBaseAPI::Recognize
  Tesseract::classify_word_and_language(&Tesseract::classify_word_pass1,...,page_res_it.word()) -- pass1
   Tesseract::classify_word_pass1(block, row, word)
    Tesseract::match_word_pass_n(1, word, row, block)
     SetupForTessRecognition() -- in this, WERD_RES.chopped_word construced
     tess_segment_pass_n(pass_n, word)
      recog_word(word)
       recog_word_recursive(word, blob_choices)
        split_and_recog_word(word, blob_choices)
        cc_recog(word)
         chop_word_main(word) // classify and chop : chopped_word -> rebuild_word, best_state, box_word
          SegSearch()
           improve_by_chopping() // repeat chopping the worst blob
            improve_one_blob() // chop word once (divide a blob in chopped_word->blobs)
  Tesseract::classify_word_and_language() -- pass2
   Tesseract::classify_word_pass2()
  
------------------------------------------------------------------------------
@ REF
Mathematical morphology
  http://en.wikipedia.org/wiki/Mathematical_morphology
Seed Filling
  http://www.leptonica.com/filling.html
  http://www.vincent-net.com/luc/papers/93ieeeip_recons.pdf
  Binary seed filling of mask image M from seed image S (S included by M) is
    union of connected components in M such that overlap with S.
    4-connectivity is top/bot/left/right, 8-conn is t/b/r/l and tr/tl/br/bl

@ Build:
http://tesseract-ocr.googlecode.com/svn/trunk/vs2008/doc/setup.html
  dl&extract files:(setup)
        leptonica-1.68-win32-lib-include-dirs.zip
        tesseract-ocr-3.02-vs2008.zip
        tesseract-ocr-3.02.02-doc-html.tar.gz
        tesseract-ocr-3.02.02.tar.gz
  build
        LIB_Release, solution build

@ Color
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0xff000000);//red
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0x00ff0000);//light green
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0x0000ff00);//blue
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0x000000ff);//black
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0x00ffff00);//lightblue
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0xff00ff00);//light red purple
  //PIX* out = pixDrawBoxa(out, box_array, 1, 0x7f00ff00);// purple

@ Resolution
linefinder-resolution <= Tesseract>source_resolution_  <= TessBaseAPI::Threshold 
   <= Thresholder::scale_ * estimated_res_
  <=estimated_res_ = yres_ = pixGetYRes(src) in  ImageThresholder::SetImage


@ max_line_width in LineFinder::GetLineMasks
max_line_width = resolution(ppi) / kThinLineFraction(20);
min_line_length = resolution / kMinLineLengthFraction(4);

@ skew
FindTabVectors



@ Tesseract::SetupPageSegAndDetectOrientation
SetupPageSegAndDetectOrientation
-LineFinder::FindAndRemoveLines     
  //input: pix
  //output:
  //  music_mask_pix, pix
  //  &v_lines, &h_lines
  GetLineMasks
    extract vline/hline pix, music_mask pix
    params: max_line_width, min_line_length
  FindAndRemoveVLines
    //Finds vertical line objects in pix_vline and removes the from src_pix.
    //output v_lines(TabVector_LIST)
    GetLineBoxes --- (add crack(intvl=100) to pix, and getconncomp)(rotate coords for horizontal)
    FindLineVectors --- extract v_lines
  FindAndRemoveHLines
    //Vと同様。XYFlipして処理しもとにもどす。
  Remove joins (intersections) where lines cross, and the residue.
  Remove any detected music.

-photo_mask_pix = ImageFind::FindImages(pix_binary_);
-find_components
-ColumnFinder

@ line detection
// Finds vertical and horizontal line objects in the given pix.
// Uses the given resolution to determine size thresholds instead of any
// that may be present in the pix.
// The output vertical_x and vertical_y contain a sum of the output vectors,
// thereby giving the mean vertical direction.
// If pix_music_mask != NULL, and music is detected, a mask of the staves
// and anything that is connected (bars, notes etc.) will be returned in
// pix_music_mask, the mask subtracted from pix, and the lines will not
// appear in v_lines or h_lines.
// The output vectors are owned by the list and Frozen (cannot refit) by
// having no boxes, as there is no need to refit or merge separator lines.
// The detected lines are removed from the pix.
void LineFinder::FindAndRemoveLines(int resolution, bool debug, Pix* pix,
                                    int* vertical_x, int* vertical_y,
                                    Pix** pix_music_mask,
                                    TabVector_LIST* v_lines,
                                    TabVector_LIST* h_lines) {

  GetLineMasks(resolution, pix, &pix_vline, &pix_non_vline, &pix_hline,
               &pix_non_hline, &pix_intersections, pix_music_mask,
               pixa_display);

  // Find lines, convert to TabVector_LIST and remove those that are used.
  FindAndRemoveVLines(resolution, pix_intersections, vertical_x, vertical_y,
                      &pix_vline, pix_non_vline, pix, v_lines);

  // call again with updated(?) hline and vline
  FilterFalsePositives(resolution, pix_non_hline, pix_intersections, pix_hline))

  FindAndRemoveHLines(resolution, pix_intersections, *vertical_x, *vertical_y,
                      &pix_hline, pix_non_hline, pix, h_lines);

  if (pix_vline != NULL && pix_hline != NULL) {
    // Remove joins (intersections) where lines cross, and the residue.
    pixAnd(pix_intersections, pix_vline, pix_hline);
    Pix* pix_join_residue = pixDilateBrick(NULL, pix_intersections, 5, 5);//enlarge
    pixSeedfillBinary(pix_join_residue, pix_join_residue, pix, 8);
    pixSubtract(pix, pix, pix_join_residue);
  }

  // Remove any detected music.
  if (pix_music_mask != NULL && *pix_music_mask != NULL) {
    pixSubtract(pix, pix, *pix_music_mask);
  }
}

@ LineFinder::GetLineMasks(int resolution, Pix* src_pix,
                              Pix** pix_vline, Pix** pix_non_vline,
                              Pix** pix_hline, Pix** pix_non_hline,
                              Pix** pix_intersections, Pix** pix_music_mask,
                              Pixa* pixa_display) {

  Pix* pix_closed = pixCloseBrick(NULL, src_pix, closing_brick, closing_brick);

  Pix* pix_solid = pixOpenBrick(NULL, pix_closed, max_line_width, max_line_width);

  Pix* pix_hollow = pixSubtract(NULL, pix_closed, pix_solid);
  *pix_vline = pixOpenBrick(NULL, pix_hollow, 1, min_line_length);
  *pix_hline = pixOpenBrick(NULL, pix_hollow, min_line_length, 1);

  // get music mask
  if (pix_music_mask != NULL) {
      *pix_music_mask = FilterMusic(resolution, pix_closed,  *pix_vline, *pix_hline, &v_empty, &h_empty);
          // find music mask and return, delete music from hline, vline
  }

  // - create pix_non_h/vline
  // - delete bad lines from pix_h/vline
  pix_nonlines = src_pix - pix_vline - pix_hline
  if (!v_empty) {
    *pix_non_vline = pixErodeBrick(NULL, pix_nonlines, kMaxLineResidue(=6), 1);//horiz shrink
    pixSeedfillBinary(*pix_non_vline, *pix_non_vline, pix_nonlines, 8);
    pix_non_vline = pix_non_vline + pix_hline - pix_intersections

    FilterFalsePositives(resolution, *pix_non_vline, *pix_intersections, *pix_vline);
      // delete BAD line segments from pix_vline.
      // - bold but short line seg, dont have >2 intersections, ...

  }
  if (!h_empty) { // same way for h lines 
    *pix_non_hline = pixErodeBrick(NULL, pix_nonlines, 1, kMaxLineResidue);
    pixSeedfillBinary(*pix_non_hline, *pix_non_hline, pix_nonlines, 8);
    pix_non_hline = pix_non_hline + pix_vline(orig) - pix_intersections(hline AND vline(orig))
    FilterFalsePositives(resolution, *pix_non_hline, *pix_intersections,   *pix_hline));
  }
}

@ FilterMusic()  music detection
// Find music and return pix_music, and delete music from hline, vline.
// Any vertical line that has at least 5 intersections in sufficient density
// is taken to be a bar. Bars are used as a seed and the entire touching
if (joins >= 5 && (joins - 1) * max_stave_height >= 4 * box_height) -> music
                           max_stave_height = resolution*1.0
                           joins = no of intersections, box_height = vline length
if (music_pixels < kMinMusicPixelFraction * all_pixels) {
 
    // False positive. Delete from the music mask.
    no of music/closed pixels in bbox of a conn comp of music pix

@ static int FilterFalsePositives(int resolution, Pix* nonline_pix,
                                Pix* intersection_pix, Pix* line_pix) {

// Helper erases false-positive line segments from the input/output line_pix.
// 1. Since thick lines shouldn't really break up, we can eliminate some false
//    positives by marking segments that are at least kMinThickLineWidth
//    thickness, yet have a length less than min_thick_length.
// 2. Lines that don't have at least 2 intersections with other lines and have
//    a lot of neighbouring non-lines are probably not lines (perhaps arabic
//    or Hindi words, or underlines.)
// Bad line components are erased from line_pix.
// Returns the number of remaining connected components.

  Boxa* boxa = pixConnComp(line_pix, &pixa, 8);
  for (int i = 0; i < nboxes; ++i) {
    Box* box = boxaGetBox(boxa, i, L_CLONE);
    Pix* comp_pix = pixaGetPix(pixa, i, L_CLONE);
    int max_width = MaxStrokeWidth(comp_pix);
    bool bad_line = false;
    if (box_width >= kMinThickLineWidth(=12) && box_height >= kMinThickLineWidth &&
        box_width < min_thick_length(=resolution*0.75) && box_height < min_thick_length &&
        max_width > kMinThickLineWidth) {
      // Too thick for the length.
      bad_line = true;
    }
    if (!bad_line &&
        (intersection_pix == NULL ||
        NumTouchingIntersections(box, intersection_pix) < 2)) {
      int nonline_count = CountPixelsAdjacentToLine(max_width, box,
                                                    nonline_pix);
      if (nonline_count > box_height * box_width * kMaxNonLineDensity)
        bad_line = true;
    }
    if (bad_line) {
       delete from line pix
    }
  }
}


@ FindLineVectors(bleft, tright, &line_bblobs, vertical_x, vertical_y, vectors);
  input line_bblobs = vline bbobs (noised)
  output vectors

  *vertical_x = 0;
  *vertical_y = 1;
  while (bbox = next bblobs ) {
    if (bbox->left_tab_type() == TT_MAYBE_ALIGNED(not alined)) {
      const TBOX& box = bbox->bounding_box();
      AlignedBlobParams align_params(*vertical_x, *vertical_y, box.width());
      TabVector* vector = blob_grid(=line_bblobs).FindVerticalAlignment(align_params, bbox,
                                                          vertical_x,
                                                          vertical_y);
      if (vector != NULL) {
        vectors.add(vector);
      }
    }
  }

FindVerticalAlignment(AlignedBlobParams align_params,

                                              BLOBNBOX* bbox,

                                              int* vertical_x,

                                              int* vertical_y)
 
  AlignTabs(align_params, false, bbox, &good_points, &ext_end_y)
    bboxから連続する線片をあつめて、good_pointsにいれ、数を返す。
  TabVector::FitVector()
    線片からベクトルをつくる。

BLOBNBOX* AlignedBlob::FindAlignedBlob(const AlignedBlobParams& p,

                                       bool top_to_bottom, BLOBNBOX* bbox,

                                       int x_start, int* end_y) {
  // not too far vertically ( ydist(center, bbox.top/bot) > max_v_gap(150) )
  // not overlap vertically
  // horiz alligned ( x coord within r/l_allign_tolerance )
  // select nearest (Euc. dist)
  // considering gradient of vertical line
  // if something in gutter, return null (end of line)

TabVector::FitVector() // Public factory to build a TabVector from a list of boxes.





@ leaders and rulers
InsertCleanPartitions
  insert leaders and rulers into the leader_and_ruling_grid_
        from part_grid

@ ColumnFinder::FindBlocks
int ColumnFinder::FindBlocks(...
                             TO_BLOCK* input_block, Pix* photo_mask_pix,
                             BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks) {
// Finds blocks of text, image, rule line, table etc, returning them in the
// blocks and to_blocks
// (Each TO_BLOCK points to the basic BLOCK and adds more information.)
// Image blocks are generated by a combination of photo_mask_pix (which may
// NOT be NULL) and the rejected text found during preliminary textline
// finding.
// The input_block is the result of a call to find_components, and contains
// the blobs found in the image or rectangle to be OCRed. These blobs will be
// removed and placed in the output blocks, while unused ones will be deleted.
// If single_column is true, the input is treated as single column, but
// it is still divided into blocks of equal line spacing/text size.
// scaled_color is scaled down by scaled_factor from the input color image,
// and may be NULL if the input was not color.
// Returns -1 if the user hits the 'd' key in the blocks window while running
// in debug mode, which requests a retry with more debug info.

  stroke_width_->FindLeaderPartitions(input_block, &part_grid_);
    // Finds leader partitions and inserts them into the given part_grid.
    // Moving between block->xxx_blobs
    //   Detected leaders become the only occupants of the input_block->small_blobs
    //   Non-leader small blobs get moved to the input_block->blobs
    //   Non-leader noise blobs remain singletons in the input_block->noise_blobs

  stroke_width_->RemoveLineResidue(&big_parts_);
    // from input_block->blobs(stroke_width_にコピーされている), 
    // find line residue (noise), 
    // and remove them (copy(append) to part_grid except them)

  FindInitialTabVectors(NULL, min_gutter_width_, input_block);
    ???

  SetBlockRuleEdges(input_block);

  stroke_width_->GradeBlobsIntoPartitions(rerotate_, input_block, nontext_map_,
                                          denorm_, &projection_,
                                          &part_grid_, &big_parts_);
    // Types all the blobs as vertical text or horizontal text or unknown and
    // puts them into initial ColPartitions in the supplied part_grid.
    // part_grid is the output grid of textline partitions.
    // Large blobs that cause overlap are put in separate partitions and added
    // to the big_parts list.
    // ここで初期パーティションを作る(blob(charaters)->part(text lines))。

  ImageFind::FindImagePartitions(photo_mask_pix, rotation_, rerotate_,
                                 input_block, this, &part_grid_, &big_parts_);

  ImageFind::TransferImagePartsToImageMask(rerotate_, &part_grid_,
                                           photo_mask_pix);

  ImageFind::FindImagePartitions(photo_mask_pix, rotation_, rerotate_,
                                 input_block, this, &part_grid_, &big_parts_);

  part_grid_.ReTypeBlobs(&image_bblobs_);

  TidyBlobs(input_block);

  ColPartition_IT p_it(&big_parts_);
  for (p_it.mark_cycle_pt(); !p_it.cycled_list(); p_it.forward())
    p_it.data()->DisownBoxes();
  big_parts_.clear();

  if (single_column) {
    // No tab stops needed. Just the grid that FindTabVectors makes.
    DontFindTabVectors(&image_bblobs_, input_block, &deskew_, &reskew_);
  } else {
    // Find the tab stops, estimate skew, and deskew the tabs, blobs and
    // part_grid_.
    FindTabVectors(&horizontal_lines_, &image_bblobs_, input_block,

                   min_gutter_width_, &part_grid_, &deskew_, &reskew_);

    // Add the deskew to the denorm_.

    DENORM* new_denorm = new DENORM;

    new_denorm->SetupNormalization(NULL, NULL, &deskew_, denorm_, NULL, 0,

                                   0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f);

    denorm_ = new_denorm;
  }
  SetBlockRuleEdges(input_block);
  part_grid_.SetTabStops(this);

  // Make the column_sets_.
  if (!MakeColumns(single_column)) {
  }

  // Refill the grid using rectangular spreading, and get the benefit
  // of the completed tab vectors marking the rule edges of each blob.
  Clear();

  InsertBlobsToGrid(false, false, &image_bblobs_, this);
  InsertBlobsToGrid(true, true, &input_block->blobs, this);

  part_grid_.GridFindMargins(best_columns_);
  // Split and merge the partitions by looking at local neighbours.
  GridSplitPartitions();

  // Resolve unknown partitions by adding to an existing partition, fixing
  // the type, or declaring them noise.
  part_grid_.GridFindMargins(best_columns_);
  GridMergePartitions();

  //Inserts remaining noise blobs into the most applicable partition if any.
  //  block->noise_blobs  => part_grid_ (replace part_grid_), delete from block->noise_blobs...
  InsertRemainingNoise(input_block);
  
  // Add horizontal/vertical line separators as partitions.
  //    from dead_vectors_/horizontal_lines_ -> part_grid_ with PT_VERT_LINE/...*********
  GridInsertHLinePartitions(); 
  GridInsertVLinePartitions();

  // Recompute margins based on a local neighbourhood search.
  part_grid_.GridFindMargins(best_columns_);
  SetPartitionTypes();

  if (equation_detect_) {
    equation_detect_->FindEquationParts(&part_grid_, best_columns_);
  }

  if (textord_tabfind_find_tables) {
    // from part_grid_, Copy cleaned partitions to clean_part_grid_ and
    // insert leaders and rulers into the leader_and_ruling_grid_, 
    // insert xxx to fragmented_text_grid_, of TableFinder
    // not setting type.
    table_finder.InsertCleanPartitions(&part_grid_, input_block);
    // Get Table Regions
    table_finder.LocateTables(&part_grid_, best_columns_, WidthCB(), reskew_);
  }
  GridRemoveUnderlinePartitions();
  part_grid_.DeleteUnknownParts(input_block);

  // Build the partitions into chains that belong in the same block and
  // refine into one-to-one links, then smooth the types within each chain.
  part_grid_.FindPartitionPartners();
  part_grid_.FindFigureCaptions();
  part_grid_.RefinePartitionPartners(true);
  SmoothPartnerRuns();

  part_grid_.AssertNoDuplicates();

  // Ownership of the ColPartitions moves from part_sets_ to part_grid_ here,
  // and ownership of the BLOBNBOXes moves to the ColPartitions.
  // (They were previously owned by the block or the image_bblobs list.)

  ReleaseBlobsAndCleanupUnused(input_block);
  // Ownership of the ColPartitions moves from part_grid_ to good_parts_ and
  // noise_parts_ here. In text blocks, ownership of the BLOBNBOXes moves
  // from the ColPartitions to the output TO_BLOCK. In non-text, the
  // BLOBNBOXes stay with the ColPartitions and get deleted in the destructor.
  TransformToBlocks(blocks, to_blocks);
  if (textord_debug_tabfind) {
    tprintf("Found %d blocks, %d to_blocks\n",
            blocks->length(), to_blocks->length());
  }

  RotateAndReskewBlocks(input_is_rtl, to_blocks);


@ TableFinder::LocateTables(ColPartitionGrid* grid,
                               ColPartitionSet** all_columns,
                               WidthCallback* width_cb,
                               const FCOORD& reskew) {

  // initialize spacing, neighbors, and columns
  InitializePartitions(all_columns);

  // find table partitions from clean_part_grid_, and put mark (PT_TABLE type) on it
  MarkTablePartitions();

  // Make single-column blocks from good_columns_ partitions. col_segments are
  // moved to a grid later which takes the ownership
  ColSegment_LIST column_blocks;
  GetColumnBlocks(all_columns, &column_blocks);

  // Set the ratio of candidate table partitions in each column
  SetColumnsType(&column_blocks);

  // Move column segments to col_seg_grid_
  MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);

  // Detect split in column layout that might have occurred due to the
  // presence of a table. In such a case, merge the corresponding columns.
  GridMergeColumnBlocks();

  // Group horizontally overlapping table partitions(clean_part_grid_, PT_TABLE) into table columns.
  ColSegment_LIST table_columns;
  GetTableColumns(&table_columns);

  ColSegment_LIST table_regions;
  GetTableRegions(&table_columns, &table_regions); 
    // from col_seg_grid_, table_columns, , create table_regions
    //  Mark region in each column that are x-bounded by the column boundaries and
    
//  y-bounded by the table_columns' projection on the y-axis, as table_regions

  // Merge table regions across columns for tables spanning multiple
  // columns
  MoveColSegmentsToGrid(&table_regions, &table_grid_); // table_regions -> table_grid_
  GridMergeTableRegions();

  // Adjust table boundaries by including nearby horizontal lines and left
  // out column headers
  AdjustTableBoundaries(); // touch &table_grid_ ??
    // expand boudary of table_grid, 
  GridMergeTableRegions(); // touch &table_grid_ ??

  if (textord_tablefind_recognize_tables) { --> カラム内のテーブルを認識する
    // Remove false alarms consiting of a single column
    DeleteSingleColumnTables();
    // Find table grid structure and reject tables that are malformed.
    RecognizeTables();
    GridMergeTableRegions();
    RecognizeTables();
  } else {
    DeleteSingleColumnTables();
  }

  // Merge all colpartitions in table regions to make them a single
  // colpartition and revert types of isolated table cells not
  // assigned to any table to their original types.
  MakeTableBlocks(grid, all_columns, width_cb);



@ TableFinder::RecognizeTables()
  // from leader_and_ruling_grid_, fragmented_text_grid_, table_grid_ ??
  // find good table from table_grid_ (correcting bbox), delete NG table from table_grid_


@ StructuredTable* TableRecognizer::RecognizeTable(const TBOX& guess)
　// recognize table and return table, by RecognizeLinedTable,etc.

@ TableRecognizer::RecognizeLinedTable(const TBOX& guess_box,
StructuredTable* table) {
  // set table->bounding_box, table->cell_x/y[]
  // collect lines intersect guess_box repeatedly, and form a table.

  if (!HasSignificantLines(guess_box)) -- check number of line_grid_ within guess_box
    return false;
  TBOX line_bound = guess_box;
  if (!FindLinesBoundingBox(&line_bound)) -- change line_bound by checking line_grid_
                                             (find bbox of lines that cross line_bound)
    return false;
  table->set_bounding_box(line_bound);
  return table->FindLinedStructure(); -- set table->cell_x/y[] reflecting line_bound...
                                         by checking line_grid_

-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
@ BBGrid, GridSearch
  BBGrid
    picture is divided into cells, cell is a rectangle with gridsize x gridsize,
    gridsize is height/width of cell in pixel count

  InsertBBox(flag, flag, bbox) register bbox to all the cell that overlap                bbox/leftedge_of_bbox/bottomedge_of_bbox according to flag. 

  RectSearch() visit cells that overlap with rect, left2right and top2bottom,
    and visit data in each cell (in ramdom order?) and return it if that overlap with rect.

  VerticalSearch(top_to_bottom mode) visit cells that overlap with rect (xmin,bot_of_grid,xmax,y),
    left2right and top2bottom,
    and visit data in each cell (in ramdom order?) and return it with no check of overlap with rect.
    Therefore, it never assure the exact order and exact overlap.


-----------------------------------------------------------------------------------

@ Algorithm

- remove stamp, image
// 基本クロース　＋　線方向に長くクローズ
closed0 = orig image closed by max_interval_of_broken_image
hline0 = closed0 open by hlen x 1
closed_hline = hline closed by max_interval_of_broken_line
closed = closed0 + closed_hline

- close/open per direction (h/v), following format property

- remove small noisy line (a part of characters, underline, etc)
remove v line segments that has less than 2 intersections to hline
//remove v line segments whose upper and lower terminals are not connected to hlines
remove short v line that intersect only short h lines
remove short & shorter v line of two v lines that run in paralell in too short separation

- remove using min_line_line_sep

- remove unconnected line segments at early stage

・スタンプ文字と線の重なり
・内部線（入れ子表、長括弧）と線がマージ。
・ふと幅2重線の抽出。
・破線罫線
・ふと線の斜めによる分断ベクトル認識
・文字がミニ格子と認識。
・交差はboxではなくimageﾍﾞｰｽで判定したい。
・突起は突起部分だけを除去する
・ベクトル化は、画像として連結していたものだけを対象としたい。
・インパルスノイズの除去
・rotate

---------------------------------------------------------------------------------------
SEGMENTATION
---------------------------------------------------------------------------------------
@ chop and classify -- chop_word_main(word)
 
@ MATRIX *rating (rating matrix)
  n x n matrix, where n = number of blobs of a word
  lower diagonal part only is used.
  value of (col, row) represents ratings of the group(chunk) of blobs from col'th to row'th
   ratings of (col,row) = BLOB_CHOICE_LIST = a list of BLOB_CHOICE (ordered in rating number??)
   BLOB_CHOICE = a set of unichar_id, rating number, matrix_cell(col and row) ...

  related functions:
   - MATRIX::print()
   - MATRIX::get(c,r) -- return value of matrix. return NOT_CLASSIFIED if value is not set yet.

@ Segmentation Graph of a word:
    node : BLOB_CHOISE in rating matrix
    parent/child nodes: n1 is parent of n2 iff n1.row + 1 == n2.col

    word consists of blobs that is ordered in left to right
    a serias of blobs constitutes a character, that is a segment

@ SegSearch()
  // The objective of the search is to find the least cost path, where the cost
  // is determined by the language model components and the properties of the
  // cut between the blobs on the path. SegSearch starts by populating the
  // matrix with the all the entries that were classified by the chopper and
  // finding the initial best path. Based on the classifier ratings, language
  // model scores and the properties of each cut, a list of "pain points" is
  // constructed - those are the points on the path where the choices do not
  // look consistent with the neighboring choices, the cuts look particularly
  // problematic, or the certainties of the blobs are low. The most troublesome
  // "pain point" is picked from the list and the new entry in the ratings
  // matrix corresponding to this "pain point" is filled in. Then the language
  // model state is updated to reflect the new classification and the new
  // "pain points" are added to the list and the next most troublesome
  // "pain point" is determined. This continues until either the word choice
  // composed from the best paths in the segmentation graph is "good enough"
  // (e.g. above a certain certainty threshold, is an unambiguous dictionary
  // word, etc) or there are no more "pain points" to explore.

  pending[] : (GenericVector<SegSearchPending>), set and used for each call of UpdateSegSearchNodes()
    // pending[col] tells whether there is update work to do to combine
    // best_choice_bundle->beam[col - 1] with some BLOB_CHOICEs in matrix[col, *].

    SetColumnClassified()       // Marks the whole column as just classified.
    SetBlobClassified(int row)  // Marks the matrix entry at the given row as just classified.
    RevisitWholeColumn()        // Marks the whole column as needing work, but not just classified.
    WorkToDo() // return true if either of the above three is set.

    Initially 
      pending[0].SetColumnClassified(). (SegSearch)
      UpdateSegSearchNodes(0,)
        Try to update each(0,r) in pending[0], set pending[r+1].RevisitWholeColumn() if updated. 
        Next, try to update the entries in pending[1], and so on.
        clear all pending
    After classify (c,r) (chopped two blobs, or popped pain_point)
      pending[c].SetBlobClassified(r); (ProcessSegSearchPainPoint)
      UpdateSegSearchNodes(c, )

  ViterbiStateEntry(VSE)
    VSE represents a path from the start nodes in segmentation graph.
    a struct ViterbiStateEntry corresponds to a node in seg graph, and
    have a back pointer to the parent vse.
    - members:
        VSE * parent_vse; // back pointer in the path
        BLOB_CHOICE *curr_b; // pointer to blob chiose
        float ratings_sum; // = parent_vse.ratings_sum + rating of the node
        float const //

    - VSE is only created in AddViterbiStateEntry in UpdateState in UpdateSegSearchNodes
      When UpdateState try to update (c,r) in pending[],
        a VSE are created for each BLOB_CHOISE of (c,r),
                          for each parent VSE in best_choice_bundle->beam[c-1]->viterbi_state_entries
          if its cost is lower than the max cost of the BLOB_CHOISE (lms->viterbi_state_entries_prunable_max_cost)

    - best_choice_bundle->beam[row].viterbi_state_entries = all vse of (*,row)
         inserted only in AddViterbiStateEntry()

  algrorithm:
    start with word_res->ratings (created in chop_word_main(), size = word->chopped_word->NumBlobs(), create ratings only on diagonal.)
    init pain_point, VSE, ...
    improve_by_chopping() : Repeatedly chops the worst blob. modify word->chopped_word->blobs
      improve_one_blob()
        chop one blob
        classify the resultant two blobs (ProcessSegSearchPainPoint)
        update VSE for the two (UpdateSegSearchNodes) 
        add new pain_points (UpdateSegSearchNodes)
    repeat:
      get one chunk(segment) from heap pain_points, with highest priority,
      classify the pain_point (ProcessSegSearchPainPoint)
      update VSE for the pp (UpdateSegSearchNodes)       
      add new pain_points (UpdateSegSearchNodes)
  
    @ pain_points insertion/deletion
    - init GenerateInitial()
         For each classified chunk(segment)(c,r) in ratings, 
           insert its left/right enhancement (c-1,r)/(c,r+1) to pain_points.
    - UpdateSegSearchNodes(start_col=0, )
       for all col >= start_col
        GenerateFromPath(best_vse,word_res)
          // A pain point is generated for each pair of neighboring blobs on the path best_vse, if it is not classified
          //    (parent and child are merged as a blob)
        GenerateFromAmbigs
          // Generate pain points from dangerous ambiguities in best choice

    - improve_by_chopping
        for each chop
          ProcessSegSearchPainPoint() called for each of two blobs
          UpdateSegSearchNodes(chopped blob number,..)
    in loop:
    - HeapPop (delete top from pain_points), classfied pain_points are skipped
    - ProcessSegSearchPainPoint(pain_point) -- gen pps (c-1,r),(c,r+1), for pain_point(c,r) 
    - UpdateSegSearchNodes(pain_point.col, ) --- gen ... 

   @ state update
   - UpdateSegSearchNodes
      UpdateState (called for all non empty (col, row)??)
       AddViterbiStateEntry
        UpdateBestChoice (only at the word_end)
         ConstructWord(BLOB_CHOICE b, ...)
          // Construct a WERD_CHOICE by tracing parent pointers.

   @ UpdateSegSearchNodes(..,start_col, ..)
       for each col from start_col, except no pending[col].WorkToDo()
         for each row for col  (only single row if pending[col].SingleRow())
           UpdateState(.., col, row, )
             for each blob_choice c in ratings->get(col,row)
               for each parent vse in best_choice_bundle->beam[col-1].viterbi_state_entries (parent segments??)
                          skipping in some condition
                 if ... continue;
                 AddViterbiStateEntry(c, vse)
       if updated
         update pain_points


@@@ CHOP  -------------------------------------------

@ pick_good_seam(blob)
  EDGEPT points[]: stores points of outlines of the blob, in order of prioriy. no of pts <= MAX_NUM_POINTS.
  
  try_point_pairs(points, num_points, &seam_queue, &seam_pile, &seam(=null), blob)
    -- for splits between all point pairs in points[], try to find best seam by choose_best_seam(..,split,&seam).
  try_vertical_splits(points, num_points, &new_points, &seam_queue, &seam_pile, &seam, blob)
    -- create split between any point in points[] and point in outlines with same x coord,
       and try to find best seam (also better than provided)  by choose_best_seam().

@ Wordrec::choose_best_seam(seam_queue, *split, PRIORITY priority, SEAM **seam_result, TBLOB *blob, seam_pile)
 -- try to create seams from the split (if given) and insert to seam_queue, 
    and try to choose the best seam from seam_queue, and set seam_result.
 -- if ream_result!=NULL, not choose the worse seam ( prioriy < prioriy(seam_result) )
 -- not choose the seam whose priority >= chop_ok_split
 -- if split given, create seam with the split (single split). 
     * the created seam uses given prioriy (that is not full but partial priority calced by caller)
     * when the seam poped from the queue, full prioriy calculated
    if the best in seam_queue is not good enough (prioriy < chop_good_split), try to combine it with others in queue 
      (create multi split seam) and insert the queue.
 -- constrain check done before setting seam_result. (constrained_split())
     * Constrain this split to obey certain rules.  It must not cross any
     * inner outline.  It must not cut off a small chunk of the outline.
 -- 

@ Priority of SEAM

 partial_split_priority(split)
  (grade_split_length(split) + grade_sharpness(split)) 
	
 seam_priority(SEAM *seam, blob.bbox.left, blob.bbox.right)
  set best pri 0 for seam without split
  set 999 for the outlines to be splitted is smaller than blob bbox in x-coord (blob.bbox.left < and < blob.bbox.right)
  else, set grade_overlap + grade_center_of_blob + grade_width_change
    grade_overlap: overlap of splitted two outlines  
    grade_center_of_blob: best if the two is large enogh, better if the two widths are similar
    grade_width_change: change of blob width before and after the split

@ Decide chop
  WERD_RES.chopped_word is created in  SetupForTessRecognition() -- see TESSLINE

 improve_by_chopping() // repeat chopping the worst blob
  repeat until( good seam found, or accepable choise found, or #blobs >= 64 )
   improve_one_blob() // chop word once (divide a blob in chopped_word->blobs)
    while(true) {
     *blob_number = select_blob_to_split_from_fixpt(fixpt);
     if (not found) *blob_number = select_blob_to_split(blob_choices, rating_ceiling, split_next_to_fragment);
     if (not found) return NULL;
     seam = chop_numbered_blob(word->chopped_word, *blob_number, italic_blob, word->seam_array);
       attempt_blob_chop(word, word->blobs[blob_number], blob_number, italic_blob, seams);
        divisible_blob(blob, italic_blob, &location)) - check if the blob contains multiple outlines that can be
                                                      separated using divide_blobs, and set the divide location.
        pick_good_seam(blob); -- if fail to divisible, pick good seam ---> see ABOBE
        apply_seam(blob, other_blob, italic_blob, seam); -- divide blob
        CheckSeam(chop_debug, blob_number, word, blob, other_blob, seams, seam);
        restore_outline_tree(blob->outlines);
        if (word->latin_script) { ... }
  
     if (seanom != NULL) return seam;  // Success!
     if (blob_choices[*blob_number] == NULL) return NULL;
     if (!split_point_from_dict) rating_ceiling = blob_choices[*blob_number]->rating();
    }
    return seam;
   ProcessSegSearchPainPoint()
   UpdateSegSearchNodes() 
              
---------------------------------------------------------------------------------------
WERD/BLOB recognition
---------------------------------------------------------------------------------------

@ PAGE_RES

  PAGE_RES
   BLOCK_RES
    BLOCK * block;
    ROW_RES
     ROW * row;
     WERD_RES
      WERD* word;
      TWERD* chopped_word;
      TWERD* rebuild_word;
      tesseract::BoxWord* box_word;
      
     
     BLOCK
      C_BLOB_LIST c_blobs;
      C_BLOB_LIST rej_blobs;
      ROW_LIST rows; 
     ROW
      WERD_LIST words;
     WERD
      C_BLOB_LIST cblobs;    
      C_BLOB_LIST rej_cblobs;

  TO_BLOCK
  
 
word()->SetupFake(unicharset); in recog_all_words()
WERD_RES::SetupForTessRecognition() in match_word_pass_n(): chopped_word = TWERD::PolygonalCopy(allow_detailed_fx, word)ROW_RES(ROW *the_row) : fuzzy word -> generate and insert combo werd_res

@ BLOB
  Textord::find_components(Pix* pix, BLOCK_LIST *blocks, TO_BLOCK_LIST *to_blocks) -- extract blobs from pix
    extract_edges(pix, block);  -- extract outlines in block->boundingbox of pix,
                                   create C_BLOBs and set block->blobs,rej_blob (ordering, nesting done)
      block_edges() -- extract outlines (closed loop of lines) from pix, 
                       and stores in C_OUTLINE_LIST of BLOCK (with out hiearchy)
      outlines_to_blobs()
        fill_buckets()
        empty_buckets()
            -- for each outermost outline, extract all children(including) outlines, 
               and create child-parent hierarchy, and make a blob for each outermost outline
          capture_children() -- extract children outlines
          ConstructBlobsFromOutlines() -- 
            position_outline()  -- create child-parent hier
    assign_blobs_to_blocks2(pix, blocks, to_blocks); 
           -- create TO_BLOCK and convert C_BLOBs of block to BOBNBOX of to_block, for each block
              setting BLOBNBOX.cblob_ptr = original CBLOB
    filter_blobs(page_tr, to_blocks, !textord_test_landscape); --- see below.

@ C_OUTLINE
  - outline exracted by find_components() consists of hor/ver lines whose length equal to pixel size.
  - C_OUTLINE have list of lines, its order is clockwise for outer outlines, anti-clockwise for innter outlines, 
    when they are created in block_edge()
  - In ConstructBlobsFromOutlines, the direcion is normalized and set INVERSE flag to each outline.

@ TESSLINE (WORD_RES.chopped_word.blobs.outlines)
  - TESSLINE also represents outlines. it is created from C_OUTLINE(word_res.word.blobs.out_list()) 
    by etupForTessRecognition()
  - TESSLINE is polygon approximated?
  - TESSLINE has no parent-children hierarchy (it is flatten). it only have a is_hole flag.
  
@ TextordPage() -- WERD recognition
SegmentPage()
 AutoPageSeg(pageseg_mode, blocks, &to_blocks, osd_tess, osr); ---> TO_BLOCK.blob, TO_ROW
 TextordPage(pageseg_mode, reskew_, width, height, pix_binary_,
                       pix_thresholds_, pix_grey_, splitting || cjk_mode,
                       blocks, &to_blocks);                               ---> BLOCK,ROW,WERD.blob
  filter_blobs(page_tr_, to_blocks, true) -- arrange blobs in to_blocks get from AutoPageSeg()
    filter_noise_blobs() --- for each to_block, move some of blobs from blobs to noise/small/large_blobs
  make_rows(page_tr_, to_blocks);
    make_initial_textrows
        -- copy .blobs in each to_block, to one of the to_row in the to_block, or it is REJECTed
      assign_blobs_to_rows
    cleanup_rows_making -- reassign blobs, and also assign large/small/noise_blobs
      assign_blobs_to_rows
  make_words(this, page_tr_, gradient, blocks, to_blocks);
    compute_fixed_pitch_cjk
    compute_fixed_pitch
    make_real_words(TO_BLOCK *block) : copy blobs from to_block.to_row, to to_block.block.row.werd
      make_rep_words
      make_blob_words
      make_prop_words   // if non fix pitch. in this func, some of blobs copied to rej_cblobs (in WERD::WERD())
      fixed_pitch_words // if fix pitch
  cleanup_blocks(blocks);  // Remove empties
    clean_small_noise_from_words // Remove outlines that are a tiny fraction in either width or height of the word height.
    clean_noise_from_row // blobs not changed...
    clean_noise_from_words // Move blobs of words from rows of garbage into the reject blobs list of the words
    tweak_row_baseline // blobs not changed...

@ outline
  C_BLOB have a list of outlines (OUTLINE_LIST)
  OUTLINE havle a list of childs (OUTLINE_LIST), child outlines are defined as those are included in the parent.

@ inverse flag of outline (white on black check)
  C_BLOB::CheckInverseFlagAndDirection() check and set inverse flag to all the outlines
     this func seems to be called when creating new CBLOB 

  WERD::WERD(C_BLOB_LIST *blob_list, uinT8 blank_count, const char *text)
    the constructor check inverse flag and reject some blobs (move to rej_cblobs) for check white-on-black char

@ assume_fixed_pitch_char_segment 
  this var is referred only in GeneratePainPoint and AssociateUtils::ComputeStats that is called by AddViterbiStateEntry  seting this var to T results in:
    - set penalty to larger(wide) wh raio
    - set penaly to or reject the blobs without right gap  --> this is a cause of Japanese text recogniion fails
    - set penalty to too small wh ratio

@ BUGS
BUG1 in GeneratePainPoint, if ok_to_extend, blobs are extended too much, and return with bad_shape
    BUG: bad_fixed_pitch_wh_ratio is referred, but not set.
BUG2 WERD constructor rejects blobs that parent-child structure of its outlines are wrong.
    -> change code of the constructor, in werd.cpp

 